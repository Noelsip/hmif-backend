#!/bin/bash
set -e

echo "ðŸš€ HMIF Backend Auto Deploy"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

# ðŸ” Cek Docker dan Docker Compose
if ! command -v docker &> /dev/null; then
    echo "âŒ Docker tidak ditemukan! Install Docker terlebih dahulu."
    exit 1
fi

if ! docker compose version &> /dev/null; then
    echo "âŒ Docker Compose tidak ditemukan! Pastikan versi Docker mendukung compose plugin."
    exit 1
fi

# ðŸ“ Validate package.json
if ! node -e "JSON.parse(require('fs').readFileSync('package.json'))" 2>/dev/null; then
    echo "âŒ package.json tidak valid atau tidak ditemukan!"
    exit 1
fi

# ðŸ§¹ Complete cleanup
echo "ðŸ§¹ Melakukan pembersihan menyeluruh..."
docker compose down --volumes --remove-orphans 2>/dev/null || true

# Remove any conflicting networks
docker network rm hmif-backend_hmif-network 2>/dev/null || true
docker network rm hmif_network 2>/dev/null || true
docker network rm hmif-network 2>/dev/null || true

# Clean up unused resources
docker system prune -f
docker volume prune -f

# ðŸŒ Update network configuration
echo "ðŸŒ Mengkonfigurasi network..."
if [ ! -f "docker-auto-env.js" ]; then
    cat > docker-auto-env.js << 'EOF'
const os = require('os');
const fs = require('fs');

// Get network interfaces
const interfaces = os.networkInterfaces();
let hostIP = 'localhost';

// Find the first non-internal IPv4 address
for (const name of Object.keys(interfaces)) {
    for (const iface of interfaces[name]) {
        if (iface.family === 'IPv4' && !iface.internal) {
            hostIP = iface.address;
            break;
        }
    }
    if (hostIP !== 'localhost') break;
}

console.log('ðŸŒ Detected IP:', hostIP);

// Update .env.docker if exists
if (fs.existsSync('.env.docker')) {
    let envContent = fs.readFileSync('.env.docker', 'utf8');
    
    // Update IP-related configurations
    envContent = envContent.replace(/HOST_IP=.*/g, `HOST_IP=${hostIP}`);
    envContent = envContent.replace(/EXTERNAL_URL=.*/g, `EXTERNAL_URL=http://${hostIP}:3000`);
    envContent = envContent.replace(/FRONTEND_URL=.*/g, `FRONTEND_URL=http://${hostIP}:3000`);
    envContent = envContent.replace(/GOOGLE_CALLBACK_URL=http:\/\/[^\/]+:3000/g, `GOOGLE_CALLBACK_URL=http://${hostIP}:3000`);
    envContent = envContent.replace(/SWAGGER_HOST=.*/g, `SWAGGER_HOST=${hostIP}`);
    
    fs.writeFileSync('.env.docker', envContent);
    console.log('âœ… Updated .env.docker with IP:', hostIP);
}
EOF
fi

node docker-auto-env.js

# ðŸ“‹ Validate .env.docker
if [ ! -f ".env.docker" ]; then
    echo "âŒ .env.docker tidak ditemukan!"
    exit 1
fi

# ðŸ” Generate SSL certificate
echo "ðŸ” Checking SSL certificate..."
mkdir -p ssl

if [ ! -f "ssl/certificate.pem" ] || [ ! -f "ssl/private-key.pem" ]; then
    echo "ðŸ” Generating SSL certificate for VPS IP: 31.97.51.165..."
    
    # Generate private key
    openssl genrsa -out ssl/private-key.pem 2048
    
    # Generate certificate dengan IP VPS
    openssl req -new -x509 -key ssl/private-key.pem -out ssl/certificate.pem -days 365 \
        -subj "/C=ID/ST=DKI Jakarta/L=Jakarta/O=HMIF/OU=Backend Team/CN=31.97.51.165"
    
    chmod 600 ssl/private-key.pem
    chmod 644 ssl/certificate.pem
    
    echo "âœ… SSL certificate generated for IP: 31.97.51.165"
else
    echo "âœ… SSL certificate already exists"
fi

# Verify SSL files
if [ -f "ssl/certificate.pem" ] && [ -f "ssl/private-key.pem" ]; then
    echo "âœ… SSL files verified:"
    echo "   - ssl/private-key.pem ($(stat -c%s ssl/private-key.pem) bytes)"
    echo "   - ssl/certificate.pem ($(stat -c%s ssl/certificate.pem) bytes)"
else
    echo "âŒ SSL files missing!"
    exit 1
fi

# ðŸ“ Create .env.docker with safe template
echo "ðŸ“ Creating .env.docker configuration..."

# Check if production credentials exist
if [ ! -f ".env.production.local" ]; then
    echo "âŒ .env.production.local tidak ditemukan!"
    echo "ðŸ’¡ Buat file .env.production.local dengan credentials production"
    echo "   Contoh:"
    echo "   GOOGLE_CLIENT_ID=your_client_id"
    echo "   GOOGLE_CLIENT_SECRET=your_client_secret"
    echo "   JWT_SECRET=your_jwt_secret"
    echo "   ..."
    exit 1
fi

# Load production credentials
echo "ðŸ” Loading production credentials..."
source .env.production.local

# Create .env.docker dengan credentials dari file terpisah
cat > .env.docker << EOF
# Docker Production Environment - Generated by auto-deploy.sh
# Server Configuration
PORT=3000
NODE_ENV=production

# VPS Configuration
VPS_IP=31.97.51.165
HOST_IP=31.97.51.165
NETWORK_SUBNET=31.97.51
SERVER_HOST=0.0.0.0

# SSL Configuration - ENABLE HTTPS
SSL_ENABLED=true
HTTPS_PORT=3443
SSL_PRIVATE_KEY_PATH=./ssl/private-key.pem
SSL_CERTIFICATE_PATH=./ssl/certificate.pem

# URLs - VPS HTTPS
EXTERNAL_URL=https://31.97.51.165:3443
FRONTEND_URL=https://31.97.51.165:3443

# Database Configuration
DATABASE_URL=mysql://root:rootpassword@mysql:3306/hmif_app

# Redis Configuration
REDIS_URL=redis://redis:6379

# Google OAuth Configuration - FROM SECURE FILE
GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}
GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}
GOOGLE_CALLBACK_URL=https://31.97.51.165:3443/auth/google/callback

# JWT Configuration - FROM SECURE FILE
JWT_SECRET=${JWT_SECRET}
JWT_EXPIRES_IN=1h
REFRESH_TOKEN_SECRET=${REFRESH_TOKEN_SECRET}
REFRESH_TOKEN_EXPIRES_IN=7d

# Session Configuration - FROM SECURE FILE
SESSION_SECRET=${SESSION_SECRET}

# ImageKit Configuration - FROM SECURE FILE
IMAGEKIT_PUBLIC_KEY=${IMAGEKIT_PUBLIC_KEY}
IMAGEKIT_PRIVATE_KEY=${IMAGEKIT_PRIVATE_KEY}
IMAGEKIT_URL_ENDPOINT=${IMAGEKIT_URL_ENDPOINT}

# Admin Configuration - FROM SECURE FILE
ADMIN_EMAILS=${ADMIN_EMAILS}

# Logging
LOG_LEVEL=info
EOF

echo "âœ… .env.docker created with production credentials"

# Remove the problematic docker-auto-env.js yang override konfigurasi
rm -f docker-auto-env.js

# Verify configuration (tanpa show credentials)
echo "ðŸ” Verifying .env.docker configuration:"
grep -E 'DATABASE_URL|GOOGLE_CALLBACK_URL|VPS_IP|SSL_ENABLED' .env.docker | sed 's/CLIENT_SECRET=.*/CLIENT_SECRET=***HIDDEN***/'

# ðŸ”¨ Build dengan no cache untuk memastikan fresh install
echo "ðŸ”¨ Building aplikasi dengan fresh dependencies..."
docker compose build --no-cache --pull

# ðŸš€ Start services dengan proper wait
echo "ðŸš€ Memulai services..."
docker compose up -d

# â³ Wait untuk services ready
echo "â³ Menunggu services siap..."
sleep 10

# ðŸ¥ Health check
echo "ðŸ¥ Melakukan health check..."
for i in {1..12}; do
    if docker compose ps | grep -q "Up.*healthy\|Up.*starting"; then
        echo "âœ… Services berhasil dimulai!"
        break
    elif [ $i -eq 12 ]; then
        echo "âŒ Services gagal dimulai setelah 60 detik"
        echo "ðŸ“‹ Cek logs untuk detail error:"
        docker compose logs --tail 20
        exit 1
    else
        echo "â³ Tunggu... ($i/12)"
        sleep 5
    fi
done

# ðŸ“Š Final status
echo ""
echo "ðŸŽ‰ Deploy berhasil!"
echo "ðŸ”“ HTTP URL: http://$(hostname -I | awk '{print $1}'):3000 (redirects to HTTPS)"
echo "ðŸ”’ HTTPS URL: https://$(hostname -I | awk '{print $1}'):3443"
echo "ðŸ“š Swagger: https://$(hostname -I | awk '{print $1}'):3443/docs-swagger"
echo "ðŸ“Š Status: docker compose ps"
echo "ðŸ“‹ Logs: docker compose logs -f app"
echo ""
docker compose ps